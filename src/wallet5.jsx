

/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/
import * as THREE from 'three'
import React, { useEffect, useRef } from 'react'
import { useGLTF, useAnimations, Html } from '@react-three/drei'
import { useFrame } from '@react-three/fiber'
import DL_bio from './DL_Face'

export default function Wallet5(props) {
  const group = useRef()
  const { nodes, materials, animations } = useGLTF('/walletnocardanimation.glb')
  const { actions, names } = useAnimations(animations, group)
  const walletOpenRef = useRef()
  const dlCardRef = useRef()
  const quat = useRef(new THREE.Quaternion())

// useEffect(() => {
//   if (walletOpenRef.current && dlCardRef.current) {
//     const initialVector = dlCardRef.current.position.clone().normalize();
//     const targetVector = walletOpenRef.current.position.clone().normalize();
    
//     if (!initialVector.equals(new THREE.Vector3()) && !targetVector.equals(new THREE.Vector3())) {
//       quat.current.setFromUnitVectors(initialVector, targetVector);
//       console.log('Quaternion calculated');
//     }
//   }
// }, [walletOpenRef.current, dlCardRef.current]);

// useFrame(() => {
//   if (walletOpenRef.current && dlCardRef.current) {
//     // Sync position if necessary
//     dlCardRef.current.position.copy(walletOpenRef.current.position);

//     // Apply the calculated quaternion
//     dlCardRef.current.quaternion.copy(quat.current);
//   }
// });
  
  
//   useEffect(() => {
//     if (walletOpenRef.current && dlCardRef.current) {
//         quat.current = (new THREE.Quaternion()).setFromUnitVectors( dlCardRef.current.position.clone().normalize(), walletOpenRef.current.position.clone().normalize());
//         console.log('worked');
//     }
//   })
//   console.log(nodes.walletopen.position)

//   useFrame(() => {
//     if (walletOpenRef.current && dlCardRef.current) {
//       dlCardRef.current.position.copy(walletOpenRef.current.position)
//       dlCardRef.current.rotation.copy(walletOpenRef.current.rotation)
//       dlCardRef.current.quaternion.copy(quat.current)
//     }
//   })

  const helper = () => {
    console.log('clicked wallet')
    actions[names[0]].fadeIn(0.5).play()
    actions[names[1]].fadeIn(0.5).play()
  }

//   const initialWalletOpenPosition = useRef(new THREE.Vector3())
//   const initialWalletOpenRotation = useRef(new THREE.Euler())
//   const initialDLCardPosition = useRef(new THREE.Vector3())
//   const initialDLCardRotation = useRef(new THREE.Euler())

//   useEffect(() => {
//     // Store the initial positions and rotations
//     if (walletOpenRef.current && dlCardRef.current) {
//       initialWalletOpenPosition.current.copy(walletOpenRef.current.position)
//       initialWalletOpenRotation.current.copy(walletOpenRef.current.rotation)
//       initialDLCardPosition.current.copy(dlCardRef.current.position)
//       initialDLCardRotation.current.copy(dlCardRef.current.rotation)
//     }
//   }, [])

//   useFrame(() => {
//     if (walletOpenRef.current && dlCardRef.current) {
//       // Calculate the change in position and rotation from the initial state
//       const positionDelta = walletOpenRef.current.position.clone().sub(initialWalletOpenPosition.current)
//       const rotationDelta = new THREE.Euler().setFromQuaternion(
//         new THREE.Quaternion().setFromEuler(walletOpenRef.current.rotation).multiply(
//           new THREE.Quaternion().setFromEuler(initialWalletOpenRotation.current).invert()
//         )
//       )

//       // Apply the changes relative to the DL_Card's original position and rotation
//       dlCardRef.current.position.copy(initialDLCardPosition.current).add(positionDelta)
//       dlCardRef.current.rotation.set(
//         initialDLCardRotation.current.x + rotationDelta.x,
//         initialDLCardRotation.current.y + rotationDelta.y,
//         initialDLCardRotation.current.z + rotationDelta.z
//       )
//     }
//   })


  useFrame(() => {
    if (walletOpenRef.current && dlCardRef.current) {
      // Apply the rotation and position of the walletspine to the DL_Card
      dlCardRef.current.position.copy(walletOpenRef.current.position)
      dlCardRef.current.rotation.copy(walletOpenRef.current.rotation)
    }
  })

  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene" onClick={helper}>
        <mesh
          name="BuisCard"
          castShadow
          receiveShadow
          geometry={nodes.BuisCard.geometry}
          material={materials.Buisness_Material}
          position={[-1.406, 3.075, -0.984]}
          rotation={[0, -0.022, 0]}
          scale={[5.751, 3.101, 0.445]}
        />
        <mesh
          name="Proj1Card"
          castShadow
          receiveShadow
          geometry={nodes.Proj1Card.geometry}
          material={materials.Project_Material}
          position={[0.421, 3.084, -0.785]}
          rotation={[0, -0.026, 0]}
          scale={[5.751, 3.101, 0.445]}
        />
        <group name="ArmatureSleeve" position={[-0.01, 0, -0.758]}>
          <skinnedMesh
            name="Sleeve"
            geometry={nodes.Sleeve.geometry}
            material={materials.Sleeve_Material}
            skeleton={nodes.Sleeve.skeleton}
          />
          <primitive object={nodes.firstfold} />
          <primitive object={nodes.firstsleeve} />
        </group>
        <mesh
          name="DL_Card"
          ref={dlCardRef}
          castShadow
          receiveShadow
          geometry={nodes.DL_Card.geometry}
          material={materials.DL_Material}
          position={[0, 3.102, 0.381]}
        //   position={[0, 20, 0.381]}
          rotation={[0, -0.022, 0]}
          scale={[5.751, 3.101, 0.445]}
        >
            <Html
                occlude
                wrapperClass="nodes"
                position={[0, 0, 0]}
                transform
                distanceFactor={2}
                rotation-y={THREE.MathUtils.degToRad(180)}
                style={{
                    pointerEvents: 'none',
                    transform: `scale(0.173882803, 0.3224766204, 2.247191011)` // Inverse scale applied to cancel out the meshâ€™s scale
                }}
              >
                <DL_bio />
              </Html>
        </mesh>
        <group
          name="ArmatureWallet"
          position={[-7.081, 0.626, -1.709]}
          rotation={[0, 0, -Math.PI / 2]}>
          <group name="Wallet">
            <skinnedMesh
              name="Cube"
              geometry={nodes.Cube.geometry}
              material={materials.Wallet_Material}
              skeleton={nodes.Cube.skeleton}
            />
            <skinnedMesh
              name="Cube_1"
              geometry={nodes.Cube_1.geometry}
              material={materials.Sleeve_Material}
              skeleton={nodes.Cube_1.skeleton}
            />
          </group>
          <primitive object={nodes.walletstay} />
          <primitive object={nodes.walletspine}>
            <primitive object={nodes.walletopen} ref={walletOpenRef} />
          </primitive>
        </group>
        <mesh
          name="Proj2Card"
          castShadow
          receiveShadow
          geometry={nodes.Proj2Card.geometry}
          material={materials.Project_Material}
          position={[0.421, 3.084, -0.514]}
          rotation={[0, -0.03, 0]}
          scale={[5.751, 3.101, 0.445]}
        />
        <mesh
          name="Proj3Card"
          castShadow
          receiveShadow
          geometry={nodes.Proj3Card.geometry}
          material={materials.Project_Material}
          position={[0.421, 3.084, -0.233]}
          rotation={[0, -0.043, 0]}
          scale={[5.751, 3.101, 0.445]}
        />
        <mesh
          name="Proj4Card"
          castShadow
          receiveShadow
          geometry={nodes.Proj4Card.geometry}
          material={materials.Project_Material}
          position={[0.421, 3.084, 0.032]}
          rotation={[0, -0.043, 0]}
          scale={[5.751, 3.101, 0.445]}
        />
        <mesh
          name="Proj5Card"
          castShadow
          receiveShadow
          geometry={nodes.Proj5Card.geometry}
          material={materials.Project_Material}
          position={[0.421, 3.084, 0.399]}
          rotation={[0, -0.056, 0]}
          scale={[5.751, 3.101, 0.445]}
        />
      </group>
    </group>
  )
}

useGLTF.preload('/walletnocardanimation.glb')